# PokeEdge .Clinerules Operational Guidelines

*Summarized from .clinerules files in /home/jrede/dev/web-app-pokeedge/.clinerules/*

## üéØ Quick Reference for Daily Development

### Core Philosophy
- **Production-grade quality always** - no shortcuts, hacks, or technical debt
- **Simplify through abstraction** - find unifying patterns that eliminate complexity
- **Systematic debugging approach** - follow structured problem-solving methods
- **Test-first development** - TDD mandatory with comprehensive coverage

## üìã Quality-First Engineering Rules

### ‚úÖ Required Standards
```javascript
// ‚ùå NEVER do this
// const tempData = fetchData(); // TODO: fix this later
// if (x) { return "value"; } else { return null; } // hack

// ‚úÖ ALWAYS do this
const data = await fetchDataWithValidation();
return validateAndProcessData(data);
```

### Definition of Done Checklist
- [ ] **Tests added/updated** - unit, integration, and e2e as needed
- [ ] **Linters/formatters pass** - zero new warnings
- [ ] **Documentation updated** - README, ADRs, migration steps
- [ ] **No temporary placeholders** - unless approved with owner/deadline
- [ ] **Clean imports/symbols** - no unused code
- [ ] **Refactors completed** - obsolete code removed

### Quality Red Flags (Stop and Fix)
- Commented-out code in production
- TODO comments without issue tracking
- Quick workarounds instead of proper solutions
- Duplicate logic across files
- Missing error handling in user interfaces

## üîÑ Simplification Cascades Rules

### When to Apply Simplification
```javascript
// ‚ùå BAD - Multiple similar implementations
function handleAmazon(item) { /* Amazon logic */ }
function handleEbay(item) { /* eBay logic */ }
function handleWalmart(item) { /* Walmart logic */ }

// ‚úÖ GOOD - One unifying abstraction
const SOURCE_CONFIGS = {
  amazon: { handler: AmazonHandler, discount: 0.05 },
  ebay: { handler: EbayHandler, discount: 0.03 },
  walmart: { handler: WalmartHandler, discount: 0.02 }
};

function handleSource(item, source) {
  const config = SOURCE_CONFIGS[source];
  return config.handler.process(item) * (1 - config.discount);
}
```

### Simplification Success Metrics
- **Net negative LOC** after refactoring
- **Fewer files/branches** removed
- **Reduced configuration** surface
- **Single abstraction** for each concept
- **Measurable complexity deletion**

### Red Flags for Missing Simplification
- "Just one more case" keeps being added
- Multiple implementations of similar logic
- Growing list of special cases
- Parallel old vs new systems
- Configuration options proliferating

## üêõ Systematic Debugging Rules

### Debugging Process (MANDATORY)
1. **Reproduce the issue** - create minimal test case
2. **Trace the code path** - add strategic logging
3. **Identify root cause** - fix the fundamental problem
4. **Verify the fix** - test thoroughly
5. **Prevent regression** - add appropriate tests

### Debugging Commands
```bash
# Find where function is defined
grep -r "def function_name" src/

# Check all references
grep -r "function_name(" src/

# View git history for changes
git log -p --follow file.py

# Find tests for module
find tests/ -name "*test*module*"
```

### After 3 Failed Fix Attempts
- Stop and reassess the architecture
- Look for unifying abstraction opportunity
- Consider if the complexity is necessary
- Ask for code review/second opinion

## üß™ Playwright MCP Testing Rules

### ALWAYS Use Playwright MCP Server
```javascript
// ‚ùå NEVER install Playwright locally
// npm install playwright  // DO NOT DO THIS

// ‚úÖ ALWAYS use MCP server
use_mcp_tool({
  server_name: "github.com/executeautomation/mcp-playwright",
  tool_name: "playwright_navigate",
  arguments: { url: "http://localhost:5176/" }
});
```

### Common Playwright MCP Patterns
```javascript
// Navigate to application
use_mcp_tool({
  server_name: "github.com/executeautomation/mcp-playwright",
  tool_name: "playwright_navigate",
  arguments: { url: "http://localhost:5176/" }
});

// Take screenshot for verification
use_mcp_tool({
  server_name: "github.com/executeautomation/mcp-playwright",
  tool_name: "playwright_screenshot",
  arguments: { name: "test-result", fullPage: true }
});

// Interact with elements
use_mcp_tool({
  server_name: "github.com/executeautomation/mcp-playwright",
  tool_name: "playwright_click",
  arguments: { selector: "[data-testid='submit']" }
});
```

### Testing Requirements
- **Start dev server first** - `npm run dev`
- **Use data-testid attributes** for reliable element selection
- **Handle browser startup time** - be patient on first run
- **Debug with console logs** - use `playwright_console_logs`

## üîß Decision Clarification Rules

### Ask for Clarification When
- Requirements are ambiguous or unclear
- Security implications are uncertain
- Architecture decisions will impact long-term maintainability
- Integration points with other systems are unclear
- Performance requirements are not defined

### Proceed Confidently When
- Well-defined task with clear inputs/outputs
- Following established patterns
- Local scope changes that are reversible
- Standard library/framework usage
- Refactoring without behavior changes

## üèóÔ∏è Self-Improving Reflection Rules

### After Each Task
- [ ] **What worked well?** - what to repeat
- [ ] **What could be improved?** - where time was wasted
- [ ] **What was learned?** - new patterns/techniques
- [ ] **How to be more efficient?** - what to do differently

### Building on Experience
- Document successful patterns as templates
- Update guidelines based on real-world usage
- Share learnings to help others
- Practice decision-making to improve skills

## üìä Development Workflow Rules

### Before Starting Any Task
1. **Understand the problem** completely
2. **Identify the root cause** if fixing a bug
3. **Design the solution** before coding
4. **Plan the tests** that will verify the solution
5. **Consider simplification opportunities**

### During Implementation
- Write tests first for new features
- Implement incrementally with validation
- Apply simplification cascades when patterns emerge
- Maintain observability signals (logging)
- Refactor as you go

### Before Committing
- Run full test suite
- Verify code quality with linters
- Check for simplification opportunities
- Ensure no technical debt introduced
- Update documentation as needed

## üö® Emergency Procedures

### Hotfix Protocol (Exception to Quality Rules)
1. **Create tracked follow-up issue** with owner and deadline
2. **Document clear rationale** in PR description
3. **Commit to cleanup plan** after stabilization
4. **Get approval** for temporary deviation

### Red Flag Response
When you notice:
- Making assumptions about requirements
- Guessing at causes without evidence
- Implementing workarounds instead of fixes
- Skipping tests to save time

**STOP and:**
1. Ask for clarification
2. Break down the problem smaller
3. Get a second opinion
4. Do more investigation

## üìà Success Metrics

### Quality Metrics
- Zero TODO comments in production
- 100% test coverage for business logic
- Zero critical linting warnings
- Production-grade error handling
- Comprehensive logging

### Simplification Metrics
- Net negative LOC after refactors
- Reduced branching complexity
- Eliminated parallel systems
- Simplified configuration surface
- Measurable complexity deletion

---

**Remember**: These rules exist to ensure PokeEdge maintains the highest quality standards while continuously becoming simpler and more maintainable. When in doubt, prioritize quality and ask for clarification rather than making assumptions.
